// Code generated by ent, DO NOT EDIT.

package ent

import (
	"github.com/bwl21/zupfmanager/internal/ent/predicate"
	"github.com/bwl21/zupfmanager/internal/ent/project"
	"github.com/bwl21/zupfmanager/internal/ent/projectsong"
	"github.com/bwl21/zupfmanager/internal/ent/song"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/entql"
	"entgo.io/ent/schema/field"
)

// schemaGraph holds a representation of ent/schema at runtime.
var schemaGraph = func() *sqlgraph.Schema {
	graph := &sqlgraph.Schema{Nodes: make([]*sqlgraph.Node, 3)}
	graph.Nodes[0] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   project.Table,
			Columns: project.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: project.FieldID,
			},
		},
		Type: "Project",
		Fields: map[string]*sqlgraph.FieldSpec{
			project.FieldTitle:     {Type: field.TypeString, Column: project.FieldTitle},
			project.FieldShortName: {Type: field.TypeString, Column: project.FieldShortName},
			project.FieldConfig:    {Type: field.TypeJSON, Column: project.FieldConfig},
		},
	}
	graph.Nodes[1] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   projectsong.Table,
			Columns: projectsong.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: projectsong.FieldID,
			},
		},
		Type: "ProjectSong",
		Fields: map[string]*sqlgraph.FieldSpec{
			projectsong.FieldPriority:   {Type: field.TypeInt, Column: projectsong.FieldPriority},
			projectsong.FieldDifficulty: {Type: field.TypeEnum, Column: projectsong.FieldDifficulty},
			projectsong.FieldComment:    {Type: field.TypeString, Column: projectsong.FieldComment},
			projectsong.FieldProjectID:  {Type: field.TypeInt, Column: projectsong.FieldProjectID},
			projectsong.FieldSongID:     {Type: field.TypeInt, Column: projectsong.FieldSongID},
		},
	}
	graph.Nodes[2] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   song.Table,
			Columns: song.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: song.FieldID,
			},
		},
		Type: "Song",
		Fields: map[string]*sqlgraph.FieldSpec{
			song.FieldTitle:     {Type: field.TypeString, Column: song.FieldTitle},
			song.FieldFilename:  {Type: field.TypeString, Column: song.FieldFilename},
			song.FieldGenre:     {Type: field.TypeString, Column: song.FieldGenre},
			song.FieldCopyright: {Type: field.TypeString, Column: song.FieldCopyright},
			song.FieldTocinfo:   {Type: field.TypeString, Column: song.FieldTocinfo},
		},
	}
	graph.MustAddE(
		"project_songs",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   project.ProjectSongsTable,
			Columns: []string{project.ProjectSongsColumn},
			Bidi:    false,
		},
		"Project",
		"ProjectSong",
	)
	graph.MustAddE(
		"project",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   projectsong.ProjectTable,
			Columns: []string{projectsong.ProjectColumn},
			Bidi:    false,
		},
		"ProjectSong",
		"Project",
	)
	graph.MustAddE(
		"song",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   projectsong.SongTable,
			Columns: []string{projectsong.SongColumn},
			Bidi:    false,
		},
		"ProjectSong",
		"Song",
	)
	graph.MustAddE(
		"project_songs",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   song.ProjectSongsTable,
			Columns: []string{song.ProjectSongsColumn},
			Bidi:    false,
		},
		"Song",
		"ProjectSong",
	)
	return graph
}()

// predicateAdder wraps the addPredicate method.
// All update, update-one and query builders implement this interface.
type predicateAdder interface {
	addPredicate(func(s *sql.Selector))
}

// addPredicate implements the predicateAdder interface.
func (pq *ProjectQuery) addPredicate(pred func(s *sql.Selector)) {
	pq.predicates = append(pq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the ProjectQuery builder.
func (pq *ProjectQuery) Filter() *ProjectFilter {
	return &ProjectFilter{config: pq.config, predicateAdder: pq}
}

// addPredicate implements the predicateAdder interface.
func (m *ProjectMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the ProjectMutation builder.
func (m *ProjectMutation) Filter() *ProjectFilter {
	return &ProjectFilter{config: m.config, predicateAdder: m}
}

// ProjectFilter provides a generic filtering capability at runtime for ProjectQuery.
type ProjectFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *ProjectFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[0].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql int predicate on the id field.
func (f *ProjectFilter) WhereID(p entql.IntP) {
	f.Where(p.Field(project.FieldID))
}

// WhereTitle applies the entql string predicate on the title field.
func (f *ProjectFilter) WhereTitle(p entql.StringP) {
	f.Where(p.Field(project.FieldTitle))
}

// WhereShortName applies the entql string predicate on the short_name field.
func (f *ProjectFilter) WhereShortName(p entql.StringP) {
	f.Where(p.Field(project.FieldShortName))
}

// WhereConfig applies the entql json.RawMessage predicate on the config field.
func (f *ProjectFilter) WhereConfig(p entql.BytesP) {
	f.Where(p.Field(project.FieldConfig))
}

// WhereHasProjectSongs applies a predicate to check if query has an edge project_songs.
func (f *ProjectFilter) WhereHasProjectSongs() {
	f.Where(entql.HasEdge("project_songs"))
}

// WhereHasProjectSongsWith applies a predicate to check if query has an edge project_songs with a given conditions (other predicates).
func (f *ProjectFilter) WhereHasProjectSongsWith(preds ...predicate.ProjectSong) {
	f.Where(entql.HasEdgeWith("project_songs", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (psq *ProjectSongQuery) addPredicate(pred func(s *sql.Selector)) {
	psq.predicates = append(psq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the ProjectSongQuery builder.
func (psq *ProjectSongQuery) Filter() *ProjectSongFilter {
	return &ProjectSongFilter{config: psq.config, predicateAdder: psq}
}

// addPredicate implements the predicateAdder interface.
func (m *ProjectSongMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the ProjectSongMutation builder.
func (m *ProjectSongMutation) Filter() *ProjectSongFilter {
	return &ProjectSongFilter{config: m.config, predicateAdder: m}
}

// ProjectSongFilter provides a generic filtering capability at runtime for ProjectSongQuery.
type ProjectSongFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *ProjectSongFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[1].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql int predicate on the id field.
func (f *ProjectSongFilter) WhereID(p entql.IntP) {
	f.Where(p.Field(projectsong.FieldID))
}

// WherePriority applies the entql int predicate on the priority field.
func (f *ProjectSongFilter) WherePriority(p entql.IntP) {
	f.Where(p.Field(projectsong.FieldPriority))
}

// WhereDifficulty applies the entql string predicate on the difficulty field.
func (f *ProjectSongFilter) WhereDifficulty(p entql.StringP) {
	f.Where(p.Field(projectsong.FieldDifficulty))
}

// WhereComment applies the entql string predicate on the comment field.
func (f *ProjectSongFilter) WhereComment(p entql.StringP) {
	f.Where(p.Field(projectsong.FieldComment))
}

// WhereProjectID applies the entql int predicate on the project_id field.
func (f *ProjectSongFilter) WhereProjectID(p entql.IntP) {
	f.Where(p.Field(projectsong.FieldProjectID))
}

// WhereSongID applies the entql int predicate on the song_id field.
func (f *ProjectSongFilter) WhereSongID(p entql.IntP) {
	f.Where(p.Field(projectsong.FieldSongID))
}

// WhereHasProject applies a predicate to check if query has an edge project.
func (f *ProjectSongFilter) WhereHasProject() {
	f.Where(entql.HasEdge("project"))
}

// WhereHasProjectWith applies a predicate to check if query has an edge project with a given conditions (other predicates).
func (f *ProjectSongFilter) WhereHasProjectWith(preds ...predicate.Project) {
	f.Where(entql.HasEdgeWith("project", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasSong applies a predicate to check if query has an edge song.
func (f *ProjectSongFilter) WhereHasSong() {
	f.Where(entql.HasEdge("song"))
}

// WhereHasSongWith applies a predicate to check if query has an edge song with a given conditions (other predicates).
func (f *ProjectSongFilter) WhereHasSongWith(preds ...predicate.Song) {
	f.Where(entql.HasEdgeWith("song", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (sq *SongQuery) addPredicate(pred func(s *sql.Selector)) {
	sq.predicates = append(sq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the SongQuery builder.
func (sq *SongQuery) Filter() *SongFilter {
	return &SongFilter{config: sq.config, predicateAdder: sq}
}

// addPredicate implements the predicateAdder interface.
func (m *SongMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the SongMutation builder.
func (m *SongMutation) Filter() *SongFilter {
	return &SongFilter{config: m.config, predicateAdder: m}
}

// SongFilter provides a generic filtering capability at runtime for SongQuery.
type SongFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *SongFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[2].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql int predicate on the id field.
func (f *SongFilter) WhereID(p entql.IntP) {
	f.Where(p.Field(song.FieldID))
}

// WhereTitle applies the entql string predicate on the title field.
func (f *SongFilter) WhereTitle(p entql.StringP) {
	f.Where(p.Field(song.FieldTitle))
}

// WhereFilename applies the entql string predicate on the filename field.
func (f *SongFilter) WhereFilename(p entql.StringP) {
	f.Where(p.Field(song.FieldFilename))
}

// WhereGenre applies the entql string predicate on the genre field.
func (f *SongFilter) WhereGenre(p entql.StringP) {
	f.Where(p.Field(song.FieldGenre))
}

// WhereCopyright applies the entql string predicate on the copyright field.
func (f *SongFilter) WhereCopyright(p entql.StringP) {
	f.Where(p.Field(song.FieldCopyright))
}

// WhereTocinfo applies the entql string predicate on the tocinfo field.
func (f *SongFilter) WhereTocinfo(p entql.StringP) {
	f.Where(p.Field(song.FieldTocinfo))
}

// WhereHasProjectSongs applies a predicate to check if query has an edge project_songs.
func (f *SongFilter) WhereHasProjectSongs() {
	f.Where(entql.HasEdge("project_songs"))
}

// WhereHasProjectSongsWith applies a predicate to check if query has an edge project_songs with a given conditions (other predicates).
func (f *SongFilter) WhereHasProjectSongsWith(preds ...predicate.ProjectSong) {
	f.Where(entql.HasEdgeWith("project_songs", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}
