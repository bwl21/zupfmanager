# Entwicklungssitzung - 18. August 2025

## Überblick

Intensive Entwicklungssitzung zur Verbesserung der Zupfmanager-Anwendung mit Fokus auf Frontend-Embedding, Build-Optimierung und Architektur-Refactoring.

## Implementierte Features und Verbesserungen

### 1. Embedded Frontend Implementation

**Problem:** Regulärer Build erforderte separate Frontend-Dateien für die Verteilung.

**Lösung:**
- Implementierung von Go embed für Frontend-Dateien
- Build-Tags für bedingte Kompilierung (`embed_frontend` vs `!embed_frontend`)
- Automatische Frontend-Pfad-Erkennung für reguläre Builds

**Dateien:**
- `pkg/api/embedded.go` - Non-embedded build (Fallback)
- `pkg/api/embedded_with_files.go` - Embedded build mit Frontend-Dateien
- `pkg/api/server_embedded.go` - Embedded file serving logic

**Ergebnis:**
```bash
# Single executable mit embedded frontend
make build-embedded
./dist/zupfmanager-embedded api --port 8080
# ✅ "Using embedded frontend files"
```

### 2. Build-System Optimierung

**Änderungen:**
- `make` erstellt jetzt standardmäßig embedded build
- Umbenennung: `build-embedded` → `build` (Standard)
- Legacy: `build` → `build-external` (externe Frontend-Dateien)
- Automatische Frontend-Pfad-Erkennung (`dist/frontend`, `frontend/dist`)

**Makefile Targets:**
```bash
make                    # Embedded build (Standard)
make build-external     # Externe Frontend-Dateien (Legacy)
make build-backend      # Backend-only build
```

### 3. Project Build Command Fixes

**Problem:** API-Aufrufe schlugen fehl mit "unknown flag: --output-dir"

**Ursachen und Lösungen:**
1. **Flag-Definition:** `--output-dir` war fälschlicherweise in `RunE` statt `init()` definiert
2. **Binary-Aufruf:** API rief falsches Binary auf (PATH vs aktuelles Binary)
3. **Flag-Inkonsistenz:** `--sample-id` vs `--sampleId` zwischen API und CLI

**Korrekturen:**
- Flag-Definition in `init()` verschoben
- API verwendet `os.Executable()` für korrektes Binary
- Flag-Namen zwischen API und CLI harmonisiert

### 4. Architektur-Refactoring: Build Logic Extraction

**Problem:** API rief CLI-Binary über `exec.Command` auf - ineffizient und fehleranfällig.

**Lösung:** Komplette Extraktion der Build-Logik in Core-Package

**Vorher:**
```
API Request → Core Service → exec.Command("zupfmanager project build") → CLI Logic
```

**Nachher:**
```
API Request → Core Service → Direct Build Logic (ExecuteProjectBuild)
```

**Implementierung:**
- Alle Build-Funktionen von `cmd/project-build.go` nach `pkg/core/project_build.go` extrahiert
- Neue `ExecuteProjectBuild` Methode im ProjectService Interface
- CLI und API verwenden beide die gleiche Core-Logik

**Extrahierte Funktionen:**
- `buildProject` - Hauptlogik
- `buildSong` - Einzelne Song-Verarbeitung
- `createToc` - Inhaltsverzeichnis-Erstellung
- `distributeZupfnoterOutput` - PDF-Verteilung
- Verschiedene Hilfsfunktionen (copyFile, mergePDFs, etc.)

### 5. Code-Bereinigung

**Entfernt:**
- `pkg/api/middleware/` - Leeres, ungenutztes Verzeichnis
- Verbesserte Logging-Nachrichten (WARN → INFO für Frontend-Fallback)

**Überprüft:**
- `frontend/src/services/` - Wird verwendet (API und WebSocket Services)
- `internal/logic` - Existiert nicht (bereits entfernt oder nie vorhanden)

## Technische Details

### Frontend Embedding
- **Build Tags:** `embed_frontend` für bedingte Kompilierung
- **Fallback-Mechanismus:** Embedded → External → API-only
- **MIME-Type Handling:** Korrekte Content-Types für alle Web-Assets
- **SPA-Routing:** Unterstützung für Vue.js Client-Side-Routing

### Build-Architektur
- **Zentralisierte Logik:** Alle Build-Funktionen in `pkg/core/`
- **Interface-basiert:** Saubere Trennung zwischen Service und Implementation
- **Fehlerbehandlung:** Robuste Error-Propagation und Logging
- **Parallelisierung:** Concurrent Song-Processing mit errgroup

### Node.js Kompatibilität
- Engine-Requirements von `^20.19.0 || >=22.12.0` auf `>=20.18.0` angepasst
- Eliminiert npm-Warnungen für Node.js v20.18.1

## Vorteile der neuen Architektur

### Performance
- ✅ Kein subprocess overhead für API builds
- ✅ Direkter Funktionsaufruf statt Binary-Execution
- ✅ Eliminiert exec.Command Sicherheitsrisiken

### Wartbarkeit
- ✅ Konsistente Build-Logik zwischen CLI und API
- ✅ Zentralisierte Business-Logic im Core-Package
- ✅ Bessere Testbarkeit durch direkte Funktionsaufrufe

### Distribution
- ✅ Single executable mit embedded frontend
- ✅ Keine externen Dateien für Produktion nötig
- ✅ Vereinfachte Deployment-Workflows

### Entwicklung
- ✅ Automatische Frontend-Pfad-Erkennung
- ✅ Backward compatibility für externe Frontend-Dateien
- ✅ Klare Trennung zwischen Development und Production builds

## Verwendung

### Produktion (Empfohlen)
```bash
make                    # Erstellt embedded build
./dist/zupfmanager api  # Single executable, keine Warnungen
```

### Entwicklung
```bash
make build-external     # Externe Frontend-Dateien
./dist/zupfmanager-external api --frontend frontend/dist
```

### API Usage
```bash
# Project build über API (funktioniert jetzt korrekt)
curl -X POST http://localhost:8080/api/v1/projects/1/build \
  -H "Content-Type: application/json" \
  -d '{"outputDir":"/custom/path"}'
```

## Commit-Historie

1. `feat: implement embedded frontend for single executable distribution`
2. `fix: resolve embedded frontend build issues`
3. `feat: add automatic frontend path detection for regular builds`
4. `fix: add missing --output-dir flag to project build command`
5. `fix: correct sampleId flag name in API build execution`
6. `improve: change embedded frontend warning to info message`
7. `feat: make embedded build the default`
8. `fix: API now uses current binary for project build execution`
9. `refactor: extract build logic to core and cleanup unused directories`

## Fazit

Die Anwendung ist jetzt deutlich robuster, effizienter und einfacher zu verteilen. Die neue Architektur eliminiert viele potentielle Fehlerquellen und verbessert sowohl die Entwickler- als auch die Endnutzer-Erfahrung erheblich.

**Nächste Schritte:**
- Testing der neuen Build-Architektur in verschiedenen Umgebungen
- Mögliche Erweiterung der Core-Services für weitere CLI-Funktionen
- Performance-Monitoring der direkten Build-Logik vs. vorherige exec-basierte Lösung
